# thr_function.py
# function [ncount,NeuralProfile] = cimodel_thrfunction(currentvec,AFieldUS,simParams)
# Function for least squares minimization (combined with a target, like 100 neurons)
# to obtain a final threshold current level from the CI Cylinder Model. Currently called by
# get_thresholds.py. The argument 'current' is in (linear) uA and should be
# a scalar if the function is to be used as a least-squares iteration function.
# 'currentvec','chnum', and 'sigma' set/override values in the 'simParams.channel' substructure.
# Input matrix 'ActiveUS' should be an unscaled version of the activating field. It is of
# size # of z-axis points x # of stimuli and can be generated by a prior call to the function
# CIMODEL_CREATEACTIVEPROFILE. There should be one entry of 'currentvec' for every
# column of 'ActiveUS'. 'simParams' is only utilized for its '.neuron' substructure, for
# a call to CIMODEL_CREATENEURALPROFILE.


import numpy as np
from scipy import special


def sigmoid_func(actr, std, x):
    retval = 0.5 * (1 + special.erf((x - actr) / (np.sqrt(2) * std)))
    return retval


def new_sigmoid(actr, std, x):  # scaled to subtract the y-intercept and still asymptote at 1.0
    y_int = sigmoid_func(actr, std, 0)
    scale_factor = 1.0 - y_int
    yval = (sigmoid_func(actr, std, x) - y_int) / scale_factor
    return yval


def create_neural_profile(active_profile, rpos_vals):
    n_z = active_profile.shape

    # Extract local values from rpos_vals structure
    act_ctr = rpos_vals['neurons']['act_ctr']
    act_std = act_ctr * rpos_vals['neurons']['act_stdrel']
    nsurvival = rpos_vals['neurons']['nsurvival']
    rlvltable = rpos_vals['neurons']['rlvl']

    # Create neural excitation profile for each input activation profile #
    neural_out = np.empty(n_z)
    neural_out[:] = np.nan

    # scale sidelobes before computing absolute value
    active_profile[active_profile < 0] = rpos_vals['neurons']['sidelobe'] * active_profile[active_profile < 0]

    # treat non-viable neurons depending on the desired algorithm
    if rpos_vals['neurons']['rule'] == 'proportional':
        atemp = new_sigmoid(act_ctr, act_std, active_profile[:])
        prop_const = rlvltable[1][-1]/rlvltable[0][-1]  # proportionality constant
        neural_out = np.multiply(atemp*prop_const, nsurvival)
    else:  # could add other models here
        raise 'Neural excitation model not recognized.'

    return neural_out


def thr_function(current, active_us, sim_params):  # simplified for scalar current

    active_profile = current * active_us  # Scale by current

    # Now call nonlinear sigmoidal activation function
    neural_profile = create_neural_profile(active_profile, sim_params)
    ncount = np.nansum(neural_profile)

    return [ncount, neural_profile, active_profile]
